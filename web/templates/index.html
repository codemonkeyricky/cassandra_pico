<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Pie Chart with Flask</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <style>
        #my_dataviz {
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
    <div id="my_dataviz"></div>

    <script>
        // Dimensions and margins
        var width = 450,
            height = 450,
            margin = 80;

        // Radius
        var radius = Math.min(width, height) / 2 - margin;

        // Append the SVG object
        var svg = d3.select("#my_dataviz")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

        // Persistent color mapping
        var colorMapping = {};
        var colorScale = d3.scaleOrdinal(d3.schemeDark2);
        var colorIndex = 0;

        // Function to get or assign a color for a label
        function getColor(label) {
            if (!colorMapping[label]) {
                colorMapping[label] = colorScale(colorIndex++);
            }
            return colorMapping[label];
        }

        // Initialize arcs
        var arc = d3.arc()
            .innerRadius(radius * 0.5)
            .outerRadius(radius * 0.8);

        var outerArc = d3.arc()
            .innerRadius(radius * 0.9)
            .outerRadius(radius * 0.9);

        // Function to update the chart
        function update(data) {
            // Pie generator
            var pie = d3.pie()
                .sort(null)
                .value(d => d.value);

            var data_ready = pie(d3.entries(data));

            // Map data to existing paths
            var slices = svg.selectAll('path')
                .data(data_ready);

            // Enter new arcs
            slices.enter()
                .append('path')
                .merge(slices)
                .attr('d', arc)
                .attr('fill', d => getColor(d.data.key)) // Use getColor to ensure consistent coloring
                .attr('stroke', 'white')
                .style('stroke-width', '2px')
                .style('opacity', 0.7);

            // Remove unused paths
            slices.exit().remove();

            // Update polylines
            var polylines = svg.selectAll('polyline')
                .data(data_ready);

            polylines.enter()
                .append('polyline')
                .merge(polylines)
                .attr("stroke", "black")
                .style("fill", "none")
                .attr("stroke-width", 1)
                .attr('points', function (d) {
                    var posA = arc.centroid(d);
                    var posB = outerArc.centroid(d);
                    var posC = outerArc.centroid(d);
                    var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                    posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1);
                    return [posA, posB, posC];
                });

            polylines.exit().remove();

            // Update labels
            var labels = svg.selectAll('text')
                .data(data_ready);

            labels.enter()
                .append('text')
                .merge(labels)
                .text(d => d.data.key)
                .attr('transform', function (d) {
                    var pos = outerArc.centroid(d);
                    var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                    pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
                    return 'translate(' + pos + ')';
                })
                .style('text-anchor', function (d) {
                    var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                    return (midangle < Math.PI ? 'start' : 'end');
                });

            labels.exit().remove();
        }

        // Fetch data and update chart every second
        function fetchData() {
            fetch('/data')
                .then(response => response.json())
                .then(data => {
                    update(data);
                });
        }

        // Initial data fetch and periodic updates
        fetchData();
        setInterval(fetchData, 1000);
    </script>

</body>

</html>